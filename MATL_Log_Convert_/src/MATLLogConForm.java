
import ij.IJ;
import ij.ImagePlus;
import ij.process.ImageProcessor;
import ij.measure.Calibration;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.Writer;
import java.text.DecimalFormat;
import java.util.Formatter;
//import java.nio.file.Files;
//import java.nio.file.Path;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JFileChooser;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.soap.Node;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathExpression;
import javax.xml.xpath.XPathExpressionException;
import javax.xml.xpath.XPathFactory;
import org.xml.sax.InputSource;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.NodeList;
import org.xml.sax.SAXException;


/**
 * Convert Olympus MATL log file to txt file for stitching in Fiji
 * 
 * @author Neil Anthony
 */

public class MATLLogConForm extends javax.swing.JFrame {
    File log_file;
    File txt_file;
    JFileChooser fc = new JFileChooser();
    
     /**
     * Creates new form FileJFrame
     */
    public MATLLogConForm() {
        initComponents();
        
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        logTextField = new javax.swing.JTextField();
        browseLogButton = new javax.swing.JButton();
        browseTxtButton = new javax.swing.JButton();
        txtTextField = new javax.swing.JTextField();
        MATL_logFileLabel = new javax.swing.JLabel();
        txtFileLabel = new javax.swing.JLabel();
        convertButton = new javax.swing.JButton();
        scrollPane = new javax.swing.JScrollPane();
        textArea = new javax.swing.JTextArea();
        zStackChkBx = new javax.swing.JCheckBox();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("Olympus MATL Log Converter");

        logTextField.setText("MATL Log File...");

        browseLogButton.setText("...");
        browseLogButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                browseLogButtonActionPerformed(evt);
            }
        });

        browseTxtButton.setText("...");
        browseTxtButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                browseTxtButtonActionPerformed(evt);
            }
        });

        txtTextField.setText("Stitching Txt File...");

        MATL_logFileLabel.setText("MATL log file");

        txtFileLabel.setText("Text file");

        convertButton.setText("Convert");
        convertButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                convertButtonActionPerformed(evt);
            }
        });

        scrollPane.setHorizontalScrollBar(null);

        textArea.setColumns(20);
        textArea.setRows(5);
        scrollPane.setViewportView(textArea);

        zStackChkBx.setText("zStacks");

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(scrollPane)
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(logTextField)
                            .addComponent(txtTextField, javax.swing.GroupLayout.DEFAULT_SIZE, 531, Short.MAX_VALUE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(browseTxtButton)
                            .addComponent(browseLogButton)))
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                        .addGap(0, 0, Short.MAX_VALUE)
                        .addComponent(zStackChkBx)
                        .addGap(18, 18, 18)
                        .addComponent(convertButton, javax.swing.GroupLayout.PREFERRED_SIZE, 92, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(MATL_logFileLabel)
                            .addComponent(txtFileLabel))
                        .addGap(0, 0, Short.MAX_VALUE)))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(MATL_logFileLabel)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(logTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(browseLogButton))
                .addGap(4, 4, 4)
                .addComponent(txtFileLabel)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(txtTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(browseTxtButton))
                .addGap(18, 18, 18)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(convertButton, javax.swing.GroupLayout.PREFERRED_SIZE, 34, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(scrollPane, javax.swing.GroupLayout.DEFAULT_SIZE, 244, Short.MAX_VALUE))
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(zStackChkBx)
                        .addGap(0, 0, Short.MAX_VALUE)))
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void browseLogButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_browseLogButtonActionPerformed

        int returnVal = fc.showOpenDialog(this);
        if (returnVal == JFileChooser.APPROVE_OPTION) {
                log_file = fc.getSelectedFile();
                try {
                    this.logTextField.setText(log_file.getCanonicalPath());  //  displays the full path of the MATL log file selected
		}
		catch(IOException e) {}
                
            } else {
                log_file = null;
            }
    }//GEN-LAST:event_browseLogButtonActionPerformed
    //  TODO - move try section below to function and call from this and from onLeaveFocus from text field
    //  OR - onClickConvert button to avoid mulitple errors on entry typos
    
    private void browseTxtButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_browseTxtButtonActionPerformed
        
        int returnVal = fc.showOpenDialog(this);
        if (returnVal == JFileChooser.APPROVE_OPTION) {
                txt_file = fc.getSelectedFile();  //  get the file returned from dialog
                try {
                    String extStr = txt_file.getName();
                    int extIndx = extStr.lastIndexOf('.');
                    if (extIndx > 0) {
                    extStr = extStr.substring(extIndx);  //  substring includes everything from index onwards
                    }
                    if(extStr.matches(".txt(.*)")) {  //  if the selection is a txt file type;  match uses regex
                        if(!txt_file.exists()){
                            boolean newTxtFile = txt_file.createNewFile();  //  create new file only if it doesn't exist
                        }
                        this.txtTextField.setText(txt_file.getCanonicalPath());  //  displays the full path of the output txt file
                    } else {
                        this.txtTextField.setText("Invalid file type...");  //  only use txt files
                        txt_file = null;
                    }
                } catch (IOException ex) {
                Logger.getLogger(MATLLogConForm.class.getName()).log(Level.SEVERE, null, ex);
                }
                
            } else {
                txt_file = null;                
            }
    }//GEN-LAST:event_browseTxtButtonActionPerformed

    private void convertButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_convertButtonActionPerformed
        //  Convert button clicked
        
        textArea.setText(null);
        final String newLine = "\n";
        String wrtLnStr;
        boolean isZ = this.zStackChkBx.isSelected();
        
        //  Setup Text file
        //Path txtPath = txt_file.toPath();
        Writer fw = null;
        try {
            fw = new FileWriter(txt_file);
        } catch (IOException ex) {
            Logger.getLogger(MATLLogConForm.class.getName()).log(Level.SEVERE, null, ex);
        }
        wrtLnStr = "# Define number of dimensions" + newLine;
        try {
            fw.write(wrtLnStr);
            if (isZ) {
                wrtLnStr = "dim = 3" + newLine;
            }
            else {
                wrtLnStr = "dim = 2" + newLine;
            }
            
            fw.write(wrtLnStr);
            wrtLnStr = "# Define image coordinate (pixels)" + newLine;
            fw.write(wrtLnStr);
        } catch (IOException ex) {
            Logger.getLogger(MATLLogConForm.class.getName()).log(Level.SEVERE, null, ex);
        }
        
        
        //  Open, create, and set DOM, doc, and XPath controls
        DocumentBuilderFactory domFactory = DocumentBuilderFactory.newInstance();
        domFactory.setNamespaceAware(true); 
        DocumentBuilder builder = null;
        try {
            builder = domFactory.newDocumentBuilder();
        } catch (ParserConfigurationException ex) {
            Logger.getLogger(MATLLogConForm.class.getName()).log(Level.SEVERE, null, ex);
        }
        Document doc = null;
        try {
            doc = builder.parse(log_file);
        } catch (SAXException ex) {
            Logger.getLogger(MATLLogConForm.class.getName()).log(Level.SEVERE, null, ex);
        } catch (IOException ex) {
            Logger.getLogger(MATLLogConForm.class.getName()).log(Level.SEVERE, null, ex);
        }
        XPathFactory xfactory = XPathFactory.newInstance();
        XPath xPath = xfactory.newXPath();
        
        Object result_xpos = null;
        Object result_ypos = null;
        Object result_fn = null;
        Object result_xno = null;
        Object result_yno = null;
        
        Object result_xsize = null;
        Object result_ysize = null;
        
        XPathExpression expr_xpos = null;
        XPathExpression expr_ypos = null;
        XPathExpression expr_fn = null;
        XPathExpression expr_xno = null;
        XPathExpression expr_yno = null;
        
        XPathExpression expr_xsize = null;
        XPathExpression expr_ysize = null;
        
        try {
            expr_xpos = xPath.compile("//XPos");
            expr_ypos = xPath.compile("//YPos");
            expr_fn = xPath.compile("//Filename");
            expr_xno = xPath.compile("//Xno");
            expr_yno = xPath.compile("//Yno");
            
            expr_xsize = xPath.compile("//XIndex");
            expr_ysize = xPath.compile("//YIndex");
            
        } catch (XPathExpressionException ex) {
            Logger.getLogger(MATLLogConForm.class.getName()).log(Level.SEVERE, null, ex);
        }
        try {
            result_xpos = expr_xpos.evaluate(doc, XPathConstants.NODESET);
            result_ypos = expr_ypos.evaluate(doc, XPathConstants.NODESET);
            result_fn = expr_fn.evaluate(doc, XPathConstants.NODESET);
            result_xno = expr_xno.evaluate(doc, XPathConstants.NODESET);
            result_yno = expr_yno.evaluate(doc, XPathConstants.NODESET);
            
            result_xsize = expr_xsize.evaluate(doc, XPathConstants.NODESET);
            result_ysize = expr_ysize.evaluate(doc, XPathConstants.NODESET);
            
        } catch (XPathExpressionException ex) {
            Logger.getLogger(MATLLogConForm.class.getName()).log(Level.SEVERE, null, ex);
        }
        
        NodeList nodes_xpos = (NodeList) result_xpos;
        NodeList nodes_ypos = (NodeList) result_ypos;
        NodeList nodes_fn = (NodeList) result_fn;
        NodeList nodes_xno = (NodeList) result_xno;
        NodeList nodes_yno = (NodeList) result_yno;
        
        NodeList nodes_xsize = (NodeList) result_xsize;
        NodeList nodes_ysize = (NodeList) result_ysize;
        
        float x_size = Float.parseFloat(nodes_xsize.item(0).getTextContent());
        float y_size = Float.parseFloat(nodes_ysize.item(0).getTextContent());
        
        int x_nodes = nodes_xpos.getLength();
        int y_nodes = nodes_ypos.getLength();
        int fn_nodes = nodes_fn.getLength();
        
        if ( x_nodes!=y_nodes || x_nodes!=fn_nodes){
            textArea.append("Log file entries mismatch." +  newLine);
            textArea.append(Integer.toString(x_nodes) + " XPos found, "
                    + Integer.toString(y_nodes) + " YPos found, " 
                    + Integer.toString(fn_nodes) + " Filenames found." + newLine);
            textArea.append("Convert aborted." + newLine);
        } else {
            textArea.append(Integer.toString(fn_nodes) + " nodes found." + newLine);
        }
        
        //  get first position values
        //  set all values as relative to this position
        float x_orig = 0;
        float y_orig = 0;
        float x_pos = 0;
        float y_pos = 0;
        
        //x_orig = Float.parseFloat(nodes_xpos.item(0).getTextContent());
        //y_orig = Float.parseFloat(nodes_ypos.item(0).getTextContent());
        
        String fnStr = "";
        String xposStr = "";
        String yposStr = "";
        String zposStr = "";
        
        //  get file extension and split for adding the mosaic number
        String extStr = "";
        fnStr = nodes_fn.item(0).getTextContent();
        int extIndx = fnStr.lastIndexOf('.');
        if (extIndx > 0) {
            extStr = fnStr.substring(extIndx);
            }
        fnStr = fnStr.replace(extStr, "");
        
        
        //  import first image and get pixel information
        String imgPathStr = null;
        try {
            imgPathStr = log_file.getCanonicalPath();
        } catch (IOException ex) {
            Logger.getLogger(MATLLogConForm.class.getName()).log(Level.SEVERE, null, ex);
        }
        String filePath = imgPathStr.substring(0,imgPathStr.lastIndexOf(File.separator)+1);
        String openStr = "open=["+filePath + fnStr+"_01"+extStr+"]";
        IJ.run("Bio-Formats Windowless Importer", openStr);
        ImagePlus imp = IJ.getImage(); 
        Double px_um = imp.getCalibration().pixelWidth;
        //ImageProcessor ip = imp.getChannelProcessor();
        //int x_pixels = ip.getWidth();
        //int y_pixels = ip.getHeight();
        double tmpPixVal = 0.0;
        double px_index_offset = x_size / px_um;  //  image center point offset in pixels, which accounts for overlap
        
        //int x_pixels = (int) imp.getCalibration().pixelWidth;
        //int y_pixels = (int) imp.getCalibration().pixelHeight;
        //IJ.run("close()");
        //StringBuilder strBuild = new StringBuilder();       
        
        try {
            //Formatter frmttr = new Formatter(wrtLnStr);
            
            for( int i = 0; i < fn_nodes; i++ ) {
                
                fnStr = nodes_fn.item(i).getTextContent();
                fnStr = fnStr.replace(extStr, "");
                
                //x_pos = Float.parseFloat(nodes_xpos.item(i).getTextContent());
                //y_pos = Float.parseFloat(nodes_ypos.item(i).getTextContent());
                
                //  TODO - use index size in pixels and x and y no's
                
                x_pos = Float.parseFloat(nodes_xno.item(i).getTextContent());
                y_pos = Float.parseFloat(nodes_yno.item(i).getTextContent());
                //xposStr = Float.toString(x_pos*x_pixels);
                //yposStr = Float.toString(y_pos*y_pixels);
                tmpPixVal = x_pos * px_index_offset;
                xposStr = String.format("%.2f", tmpPixVal);
                tmpPixVal = y_pos * px_index_offset;
                yposStr = String.format("%.2f", tmpPixVal);
                zposStr = "0.00";
    
                
                if (isZ) {
                    wrtLnStr = fnStr + "_01" + extStr + "; ; (" + xposStr + ", " + yposStr +", " + zposStr + ")" + newLine;
                }
                else {
                    wrtLnStr = fnStr + "_01" + extStr + "; ; (" + xposStr + ", " + yposStr +")" + newLine;
                }
                //  below pre2018
                //xposStr = Float.toString(x_pos*x_size);
                //yposStr = Float.toString(y_pos*y_size);
                
                fw.write(wrtLnStr);
                textArea.append(wrtLnStr);
            }
            
            fw.close();
        } catch (IOException ex) {
            Logger.getLogger(MATLLogConForm.class.getName()).log(Level.SEVERE, null, ex);
                }
        
    }//GEN-LAST:event_convertButtonActionPerformed

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(MATLLogConForm.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(MATLLogConForm.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(MATLLogConForm.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(MATLLogConForm.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new MATLLogConForm().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JLabel MATL_logFileLabel;
    private javax.swing.JButton browseLogButton;
    private javax.swing.JButton browseTxtButton;
    private javax.swing.JButton convertButton;
    private javax.swing.JTextField logTextField;
    private javax.swing.JScrollPane scrollPane;
    private javax.swing.JTextArea textArea;
    private javax.swing.JLabel txtFileLabel;
    private javax.swing.JTextField txtTextField;
    private javax.swing.JCheckBox zStackChkBx;
    // End of variables declaration//GEN-END:variables
}
